<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
</head>
<body style="margin: 0; padding: 0; width: 100%; height: 100%">
<canvas id="can" style="">

</canvas>

<script>

var can = document.getElementById("can");
var ctx = can.getContext('2d');

var linesIntersect = function(lineA, lineB) {
	var A = { X: lineA[0], Y: lineA[1] },
		B = { X: lineA[2], Y: lineA[3] },
		C = { X: lineB[0], Y: lineB[1] },
		D = { X: lineB[2], Y: lineB[3] },
		CmP = { X: C.X - A.X, Y: C.Y - A.Y },
		r =   { X: B.X - A.X, Y: B.Y - A.Y },
		s =   { X: D.X - C.X, Y: D.Y - C.Y },
		CmPxr = CmP.X * r.Y - CmP.Y * r.X,
		CmPxs = CmP.X * s.Y - CmP.Y * s.X,
		rxs = r.X * s.Y - r.Y * s.X;

	if (CmPxr === 0) {
		return ((C.X - A.X < 0) != (C.X - B.X < 0)) ||
			((C.Y - A.Y < 0) != (C.Y - B.Y < 0));
	}

	if (rxs == 0) { return false; }
	var rxsr = 1 / rxs,
		t = CmPxs * rxsr,
		u = CmPxr * rxsr;

	return (t >= 0) && (t <= 1) && (u >= 0) && (u <= 1);
};

var Bar = function(x, y, radius, rotation, thickness, ctx) {
	var ang, lx, ly, rx, ry;
	this.setRotation = function(rot) {
		ang = rot * (Math.PI / 180);
		ly = parseInt(Math.ceil(y - Math.sin(ang) * radius), 10);
		lx = parseInt(Math.ceil(x - Math.cos(ang) * radius), 10);
		rx = parseInt(Math.ceil(x + Math.cos(ang) * radius), 10);
		ry = parseInt(Math.ceil(y + Math.sin(ang) * radius), 10);
	}

	this.draw = function() {
		ctx.beginPath();
		ctx.lineWidth = thickness;
		ctx.moveTo(lx, ly);
		ctx.lineTo(rx, ry);
		ctx.stroke();
	};

	this.getLineVector = function() {
		return [lx, ly, rx, ry];
	};
	
	this.getAngle = function() {
		return ang;
	}
	
	this.setRotation(rotation);
	return this;
};

var Marble = function(x, y, angle, bars, radius, ctx) {
	var _x = x, _y = y, x1 = x, y1 = y, maxAcc = 3, 
		rad90 = 90 * (Math.PI / 180),
		rad180 = Math.PI,
		rad360 = 360 * (Math.PI / 180),
		acc = 0,
		ang = angle,
		wasFlying = true;
	
	function gravAcceleration() {
		return  ang > rad90
			? (rad180 - ang) * 0.008
			: ang * 0.008;
	}
	
	function collidesWithBar(_ang) {
		for (var i = 0; i < bars.length; i++) {
			var collides = linesIntersect(
				bars[i].getLineVector(),
				[_x, _y, _x + Math.cos(_ang) * (radius + 1),
						 _y + Math.sin(_ang) * (radius + 1)]
			);
			if (collides) {
				return {
					collides: true,
					angle: bars[i].getAngle()
				};
			}
		}
		return {
			collides: false
		};
	}


	this.accelerate = function() {
		acc += gravAcceleration();
		_y += Math.sin(ang) * acc;
		_x += Math.cos(ang) * acc;
		x1 = parseInt(Math.ceil(_x), 10);
		y1 = parseInt(Math.ceil(_y), 10);
		
		var collision = collidesWithBar(rad90);
		if (collision.collides) {
			ang = collision.angle;
			if (collision.angle === rad180 || collision.angle === 0) {
				acc = 0;
			}
		} else {
			wasFlying = true;
			if (ang < rad90) {
				ang += 0.1;
			} else if (ang > rad90) {
				ang -= 0.1;
			}
		}
		

	};

	this.draw = function() {
		ctx.beginPath();
		ctx.fillStyle = "red";
		ctx.arc(
			x1,y1,
			radius - 1,  0, 2 * Math.PI, false
		)
		ctx.fill();
	};
};

var bars = [
	new Bar(140, 50, 30, 0, 2, ctx),
	new Bar(240, 50, 30, 0, 2, ctx),
	new Bar(140, 150, 150, 25, 4, ctx)
];

var marbles = [
	new Marble(120, 10, 0, bars, 8, ctx), 
	new Marble(140, 10, 0, bars, 8, ctx),
	new Marble(220, 10, 0, bars, 8, ctx), 
	new Marble(240, 10, 0, bars, 8, ctx),
];

window.setTimeout(function() { bars.shift(); }, 3000);

window.setTimeout(function() { bars.shift(); }, 2000);


var FrameRenderer = function(ctx) {
	var width, height;
	this.onResize = function(w, h) {
		width = w;
		height = h;
	};
	
	function render() {
		ctx.clearRect(0,0,width,height);
		for (var i = 0; i < bars.length; i++) {
			bars[i].draw();
		}
		for (var i = 0; i < marbles.length; i++) {
			marbles[i].draw();
		}
		requestAnimationFrame(render);
	}

	requestAnimationFrame(render);
	return this;
};

var frameRenderer = new FrameRenderer(ctx);

window.setInterval(function() {
	for (var i = 0; i < marbles.length; i++) {
		marbles[i].accelerate();
	}
}, 10);

var resizeListeners = (function(canvas) {
	function log() { console.log(arguments); }
	function rescaleGame(width, height) {
		canvas.width = width;
		canvas.height = height;
	}

	return [log, rescaleGame, frameRenderer.onResize];
})(can);

var viewPort = (function(listeners) {
	function onResize() {
		resizeListeners.forEach(function (listener) { 
			listener(window.innerWidth, window.innerHeight);
		});
	}
	
	onResize();
	window.addEventListener("resize", onResize);
	return this;
})(resizeListeners);

</script>
</body>
</html>
